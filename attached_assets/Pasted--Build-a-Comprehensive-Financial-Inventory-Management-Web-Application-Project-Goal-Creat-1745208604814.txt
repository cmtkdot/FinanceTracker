## Build a Comprehensive Financial & Inventory Management Web Application

**Project Goal:** Create a full-stack web application with a robust administrator dashboard and a secure customer/vendor portal. The system must manage core business financials (Estimates, Invoices, Purchase Orders, Payments, Credits) and inventory. All **complex calculations, cascading data updates, and core relationship linking** must be handled automatically and accurately **within the PostgreSQL database**. The application will be built from scratch.

**Key Database Requirements (PostgreSQL):**

The database schema is central to this application. For each primary business record originating from an external system (like Glide):

1.  It MUST have a **database-native Primary Key** (`id` column, use UUIDs for unique identification).
2.  It MUST store its **original external row identifier** (`glide_row_id` column, use TEXT, must be Unique).
3.  For relationships inherited from the external system, the child record MUST store the **original external identifier of the parent** (`rowid_[parent_table_name]` column, use TEXT) AND a **database-native Foreign Key** (`[parent_table_name]_id` column, use UUID, referencing the `id` of the parent row).

**Application Logic Distribution:**

*   **PostgreSQL Database:** Handles schema definition (tables, columns, types, constraints, indexes, UUID PKs/FKs, `glide_row_id`, `rowid_*`), `GENERATED ALWAYS AS` columns (for simple calculations), Triggers (for detecting data changes and sending notifications), and Functions (for complex calculations, lookups, and logic called by the external handler).
*   **Application Backend:** Handles database connection, basic CRUD operations using an ORM, authentication, authorization checks based on UUID FKs, and sending webhooks to the external handler *after* relevant database changes.
*   **External Webhook Handler (e.g., n8n):** Receives webhooks from the backend, performs lookups (potentially using `rowid_` to find internal UUIDs), and calls specific PostgreSQL database functions to execute complex, cascading logic.

**Core Data Entities & Relationships (Design & Implement in PostgreSQL):**

Design and implement the schema based on these entities and their relationships. **Crucially, ensure the hybrid key structure is applied correctly.**

1.  **Accounts:** Represents clients/customers and vendors.
    *   *Relationships:* Many Estimates, Invoices, Purchase Orders, Customer Payments, Vendor Payments relate *to* an Account. A Product can be supplied by an Account (as a vendor).
    *   *Logic:* Accounts track `customer_balance`, `vendor_balance`, and `net_balance` derived from related documents (calculated by DB functions). Each Account has a unique `account_uid` (generated by DB trigger).

2.  **Products:** Items/services in the catalog.
    *   *Relationships:* Products are referenced by Estimate Line Items, Invoice Line Items, Purchase Order Lines, and Vendor Payments. A Product is supplied by an Account (vendor). External Messages (e.g., from Telegram) can be linked to a Product via a matching process.
    *   *Logic:* Products have calculated inventory levels (stock, committed, sold, available - derived by DB functions/views) based on linked documents. Products have a `display_name` (generated column) and a unique `sku` (generated/mapped). Media URLs (photo, video) are updated based on linked Messages (managed by DB trigger/webhook handler).

3.  **Estimates:** Sales quotes to clients.
    *   *Relationships:* An Estimate belongs to an Account (client). An Estimate has many Estimate Line Items. Customer Credits can apply to an Estimate. An Estimate can be converted into an Invoice.
    *   *Logic:* Estimates have calculated `total_amount`, `total_credits`, and `balance` (calculated by DB functions). Each has a unique `estimate_uid` (generated by DB trigger). A flag indicates if it's converted to an Invoice.

4.  **Estimate Line Items:** Details on an Estimate.
    *   *Relationships:* Belongs to an Estimate. References a Product.
    *   *Logic:* Has a calculated `line_total` (generated column). Has a `display_name` (derived by DB trigger/webhook handler).

5.  **Invoices:** Sales bills to clients.
    *   *Relationships:* An Invoice belongs to an Account (client). An Invoice has many Invoice Line Items. Customer Payments can apply to an Invoice. Customer Credits can apply to an Invoice. An Invoice can originate from an Estimate.
    *   *Logic:* Invoices have calculated `total_amount`, `total_paid`, and `balance` (calculated by DB functions). Tracks `payment_status` (derived by DB trigger). Each has a unique `invoice_uid` (generated by DB trigger).

6.  **Invoice Line Items:** Details on an Invoice.
    *   *Relationships:* Belongs to an Invoice. References a Product.
    *   *Logic:* Has a calculated `line_total` (generated column). Has a `display_name` (derived by DB trigger/webhook handler).

7.  **Purchase Orders:** Orders placed with vendors.
    *   *Relationships:* A Purchase Order belongs to an Account (vendor). A Purchase Order has many Purchase Order Lines (linked products). Vendor Payments can apply to a Purchase Order.
    *   *Logic:* Purchase Orders have calculated `total_amount`, `total_paid`, and `balance` (calculated by DB functions). Tracks `payment_status` (derived by DB trigger). Tracks `product_count` (calculated by DB function). Each has a unique `po_uid` (generated by DB trigger).

8.  **Purchase Order Lines:** (Implement as a separate table linking POs and Products for clarity)
    *   *Relationships:* Belongs to a Purchase Order. References a Product.
    *   *Logic:* Has a calculated `line_total` (generated column: quantity * unit_cost).

9.  **Customer Payments:** Payments received.
    *   *Relationships:* Belongs to an Account (client). Applies to an Invoice.
    *   *Logic:* Tracks `status` ('pending', 'approved', 'rejected') for an admin approval workflow (managed by backend/webhook handler). Triggers updates to Invoice totals/balance (managed by webhook handler calling DB function).

10. **Vendor Payments:** Payments made.
    *   *Relationships:* Belongs to an Account (vendor). Applies to a Purchase Order. Can reference a specific Product on the PO (optional, define relationship if needed).
    *   *Logic:* Triggers updates to Purchase Order totals/balance (managed by webhook handler calling DB function).

11. **Customer Credits:** Credits issued.
    *   *Relationships:* Belongs to an Account (client). Can apply to an Invoice or an Estimate.
    *   *Logic:* Triggers updates to Document balance (managed by webhook handler calling DB function).

12. **Expenses:** Business costs (implement if needed for comprehensive profit reporting).
    *   *Relationships:* Can link to a user (optional).
    *   *Logic:* Contributes to overall business expenses (used in reports/MVs).

13. **Messages:** External data source (e.g., Telegram).
    *   *Relationships:* Can link to a Product.
    *   *Logic:* Contains `extracted_data` (JSONB) including a `product_sku` (derived/extracted). This `product_sku` is used to match and link to a `products` record. If matched, updates `messages.product_id` and copies message media URLs to the linked Product (`products.public_url_photo`/`_video`). Managed by DB trigger/webhook handler.

**PostgreSQL Database Logic Implementation:**

Implement the following using PL/pgSQL Functions and Triggers:

*   `set_updated_at()`: Function for `updated_at` trigger.
*   UID Generation Functions & Triggers: Implement functions like `generate_account_uid(uuid)`, `generate_estimate_uid(uuid, timestamptz, bool)`, etc., and triggers calling them BEFORE INSERT/UPDATE, using the UUID FKs (`NEW.[parent]_id`) and relevant date/flags.
*   `update_[document]_finance_metrics(uuid)` functions (`update_invoice_finance_metrics`, `update_estimate_finance_metrics`, `update_po_finance_metrics`): Accept a document UUID, calculate its totals/paid/credits/balance using UUID FKs for internal queries, and update the document row. **Called by the external webhook handler.**
*   `update_account_customer_balance(uuid)` function: Recalculates `customer_balance` for an account ID by summing balances of linked invoices (using UUID FKs). **Called by the external webhook handler.**
*   `update_account_vendor_balance(uuid)` function: Recalculates `vendor_balance` for an account ID by summing balances of linked POs (using UUID FKs). **Called by the external webhook handler.**
*   `update_account_net_balance()`: Function/trigger to calculate `net_balance`.
*   `set_[entity]_display_name()` functions: Derive display names. Called by DB triggers BEFORE save or by webhook handler.
*   `handle_message_product_link_db(uuid)` function: Accepts a message UUID. Finds product match by `messages.sku`, updates `messages.product_id`, and updates the product's media URLs. **Called by the external webhook handler.**
*   `convert_estimate_to_invoice_db(uuid)` function: Creates a new invoice/lines from an estimate, populating UUID FKs. **Called by backend API or webhook handler.**
*   `approve_customer_payment_db(uuid)` function: Updates payment status to 'approved'. **Called by backend API or webhook handler.**
*   PDF Generation: Functions (`queue_pdf_generation_for_record`, `process_pdf_generation_queue`, logging) for managing a PDF queue (triggered by DB triggers or scheduled jobs).
*   Inventory Calculation: Functions/Views (`calculate_product_inventory(uuid)`, `v_product_inventory`) to derive inventory levels using UUID FKs.
*   Views & Materialized Views: Create views and MVs for reporting performance (`mv_monthly_financial_summary`, `mv_account_finance_summary`, `mv_customer_aging`, `mv_vendor_aging`, `mv_category_sales_summary`, `mv_product_sales_summary`, `v_recent_transactions`), joining tables using UUID FKs. Include scripts for refreshing MVs.

**Application Backend (Orchestration & Webhook Sending):**

*   Use a suitable ORM for PostgreSQL.
*   Define ORM schema mapping the PostgreSQL structure, including UUID PKs/FKs and text `glide_row_id`/`rowid_*`.
*   Implement backend API endpoints for Admin and Secure Portal features.
*   Perform basic CRUD operations using the ORM.
*   **After any INSERT, UPDATE, or DELETE operation on tables that require complex cascading updates (e.g., estimates, estimate_line_items, invoices, invoice_line_items, purchase_orders, purchase_order_lines, customer_payments, vendor_payments, customer_credits, products, messages), the backend MUST send a webhook (HTTP POST) to the external webhook handler URL.** The webhook payload should contain:
    *   `table`: Name of the table that changed.
    *   `id`: The UUID of the row that changed.
    *   `op`: The operation type ('INSERT', 'UPDATE', 'DELETE').
    *   `row`: The *new* state of the row (for INSERT/UPDATE).
    *   `old_row`: The *old* state of the row (for UPDATE/DELETE).
*   Implement Admin Authentication (email/password login).
*   Implement Authorization checks in API endpoints using user roles and verifying relationships via UUID FKs when querying/mutating data.
*   Implement Secure Portal endpoints with PIN verification logic. Query data filtered by the accessed Account's UUID ID using UUID FK joins.

**External Webhook Handler (e.g., n8n - Processes Complex Logic):**

*   Receive webhooks from the backend application.
*   Based on the received `table`, `id`, `op`, `row`, `old_row`:
    *   Identify the affected document or account UUIDs (using `id` or by looking up `id` from `rowid_` if necessary).
    *   Call the appropriate PostgreSQL database functions via a database execution node/API:
        *   If `invoice_line_items` changed, call `update_invoice_finance_metrics(invoice_id)`.
        *   If `customer_payments` changed, call `update_invoice_finance_metrics(invoice_id)`.
        *   If `invoices.balance` changed (requires checking `old_row.balance` vs `row.balance` in the webhook handler logic), call `update_account_customer_balance(account_id)`.
        *   If `messages` changed (with SKU/media), call `handle_message_product_link_db(message_id)`.
        *   ... and so on for all cascading updates defined in the DB logic section.
*   Manage multi-step workflows (Estimate conversion, Payment approval) by calling the relevant database functions (`convert_estimate_to_invoice_db`, `approve_customer_payment_db`).

**Frontend Application:**

*   Build Admin Dashboard and Secure Portal UI.
*   Interact with backend API endpoints.
*   Implement PIN entry logic.
*   Ensure mobile-first responsive design and specified style guide.

**Security:**

*   Backend Authentication (Admin login).
*   Backend Authorization (API endpoint checks using roles and UUID relationships).
*   Secure links + PIN for portal access.
*   Database secured via network rules (allow connections only from backend and webhook handler).

**Design & Branding:**

*   Follow the specified Style Guide (Colors, Fonts, Design principles: Stripe/Square/Cash App/iOS PIN).

**Output Requirements:**

*   Complete application codebase (backend with ORM schema, API endpoints, webhook sending logic; frontend application).
*   Full, runnable PostgreSQL schema script (tables with UUID PKs/FKs and `glide_row_id`/`rowid_*`, constraints, indexes, generated columns, functions, triggers, views, materialized views).
*   Implementation of all specified database functions and triggers (including the simple webhook notification triggers).
*   Explanation of the webhook/n8n flow and how it calls database functions.
*   README with detailed instructions for setup (PostgreSQL, backend, webhook handler), configuration, deployment, and testing.